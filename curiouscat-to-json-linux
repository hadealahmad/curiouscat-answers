# code from https://github.com/elmoiv/ccapi edited for linux support and ajax saving instead of txt
import requests, json, os, webbrowser
from datetime import datetime

# Find everything between A and B
# (?<=A)(.*)(?=B)-
def pgbr(prcnt, dn='█', rm='░', length=100, hint=''):
    # dn: done
    # rm: remaining
    d = int(prcnt * length)
    r = length - d
    print(f'\r{hint} |{dn*d}{rm*r}| {int(prcnt*100)}%', end='\r')

def gtall(name, d):
    # api only shows 100 messages in api
    # i noticed that when i scroll page
    # there is a new requests for the api with parameter (max_timestamp)
    # which each message on api has one
    # so i get the last message time stamp (message number 100) and subtract 1
    # so the next request can get the rest <= 100 messages without repeating the
    # last message from the previous request
    # when n equals the static property of answers numbers the code stops
    messages = []
    dct, n, last = {}, 0, 0
    profile_info = {
        "username": d["username"],
        "answers": d["answers"],
        "followers": d["followers"],
        "following": d["following"],
        "twitter": f'https://twitter.com/intent/user?user_id={d["userData"]["twitterid"]}',
        "messages": messages
    }

    if not d['posts']:
        profile_info["messages"] = '[No Messages _/(0_0)\\_]'
        return profile_info

    while True:
        try:
            dct = json.loads(
                requests.get(
                    f'https://curiouscat.me/api/v2/profile?username={name}&count=100' + f'&max_timestamp={last}' * (last != 0)
                ).content.decode()
            )
            for post in dct['posts']:
                messages.append({
                    "timestamp": datetime.utcfromtimestamp(post['timestamp']).strftime('%Y-%m-%d %H:%M:%S'),
                    "message": post["comment"],
                    "reply": post["reply"]
                })
            n += len(dct['posts'])
            pgbr(n/dct["answers"], hint='Answers fetched:')
            if not dct['posts']:
                break
            last = dct['posts'][-1]['timestamp'] - 1
        except:
            profile_info["messages"].append("[Unexpected Error]")
            break

    return profile_info

def foloDetail(name, identifier):
    fls = json.loads(requests.get(f'https://curiouscat.me/api/v2/profile/{identifier}?username={name}').content.decode())
    with open(f'{name}/{identifier}.json', 'w') as fs:
        json.dump([{"username": flwr["username"], "profile_link": f'https://curiouscat.me/{flwr["username"]}'} for flwr in fls['result']], fs, indent=4)

def cc():
    name = input('Username: ')
    dct = json.loads(requests.get(f'https://curiouscat.me/api/v2/profile?username={name}').content.decode())
    if 'error' in dct:
        print("\nProfile doesn't exist!")
        return
    os.makedirs(f'{name}', exist_ok=True)
    foloDetail(name, 'followers')
    foloDetail(name, 'following')
    with open(f'{name}/avatar.jpg', 'wb') as img:
        img.write(requests.get(dct['avatar']).content)

    # Fetch and save all messages in JSON format
    profile_data = gtall(name, dct)
    with open(f'{name}/answers.json', 'w', encoding='utf-8') as db:
        json.dump(profile_data, db, indent=4)

    webbrowser.open(f'{name}/')

os.makedirs('DATA', exist_ok=True)
os.chdir('DATA')
while True:
    try:
        os.system('clear')  # Linux terminal clear command
        cc()
        input('\nNext?')
    except KeyboardInterrupt:
        input('Why Ctrl+C? (-_-)')
